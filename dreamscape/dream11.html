<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dream 11</title>
  <link rel="stylesheet" href="https://use.typekit.net/duf4kqx.css">
  <style>
    html,body{height:100%;margin:0}
    body{background:#16161d;overflow:hidden;}
    body.dream1{cursor:none}
    #container{position:relative;width:100vw;height:100vh}
    video#cam{position:fixed;left:12px;bottom:12px;width:320px;height:180px;object-fit:cover;z-index:1000;}
    canvas#overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .virtual-cursor{position:fixed;left:0;top:0;width:18px;height:18px;border-radius:50%;background:#d3cec0;transform:translate(-50%,-50%);transition:transform 0.06s linear;z-index:9999;pointer-events:none}

    /* Center dream1 button */
    #back{
      position: fixed;
      top: 64%;
      left: 2%;
      z-index: 2000; /* ensure it’s above the video */
      cursor: pointer;
      width: 7vw;
      height: 7vw;
      background-image: url('images/back.png');
      background-size: cover;
      background-color: transparent;
      border: none;
    }
    #back.hand-hover {
      background-image: url('images/backhover.png');
    }

    #phobia {
      position: absolute;
      top: 0%;
      left: 0%;
      margin: 3vw;
      color: #3effff; 
      line-height: 1.1;
      font-size: 6.5vw;
      font-family: firelli-variable, sans-serif;
      font-variation-settings: "wght" 100;
    }

    @keyframes letter-wiggle {
  0%   { transform: rotate(0deg); }
  25%  { transform: rotate(-3deg); }
  50%  { transform: rotate(0deg); }
  75%  { transform: rotate(3deg); }
  100% { transform: rotate(0deg); }
}

#phobia .phobia-letter {
  display: inline-block;
  transform-origin: 50% 100%; /* baseline */
  transition: transform 0.3s ease-out; /* smooth reset */
}

#phobia .phobia-letter.hand-letter-hover {
  animation: letter-wiggle 0.8s ease-in-out infinite;
}

#phobia .phobia-letter.ripple-1 {
  animation: letter-wiggle 1.2s ease-in-out infinite;
}

#phobia .phobia-letter.ripple-2 {
  animation: letter-wiggle 1.8s ease-in-out infinite;
}

#phobia {
  max-width: 100%;
  white-space: normal;
  word-break: normal;
}

/* word container */
#phobia .phobia-word {
  display: inline-block;
  white-space: nowrap;
  margin-right: 0.4em; /* controls word spacing */
}

/* remove margin on last word */
#phobia .phobia-word:last-child {
  margin-right: 0;
}

  </style>
</head>
<body class="dream1">

  <button id="back"></button>

  <div id="container">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="virtual-cursor" id="vcursor"></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js?ver=stable"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.4/camera_utils.js?ver=stable"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.4/drawing_utils.js?ver=stable"></script>

  <script>
  window.onload = () => {
    const video = document.getElementById('cam');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    vcursor = document.getElementById('vcursor');

    function log(...args){ console.log(...args); }

    function resizeCanvas(){ overlay.width = window.innerWidth; overlay.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas); resizeCanvas();

    // Stable hands model
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`});
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.1,
      minTrackingConfidence: 0.1
    });
    hands.onResults(onHands);

    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user', width:1280, height:720}, audio:false});
        video.srcObject = stream;
        await video.play();

        // Offscreen canvas for non-mirrored input to hands
        const flipped = document.createElement('canvas');

        // Wait until video metadata is loaded to set canvas size
        video.addEventListener('loadedmetadata', () => {
          flipped.width = video.videoWidth;
          flipped.height = video.videoHeight;
        });

        const sendFrame = async () => {
          if(video.readyState >= 2){
            // ensure offscreen canvas size matches (in case loadedmetadata fired earlier)
            if (flipped.width !== video.videoWidth || flipped.height !== video.videoHeight) {
              flipped.width = video.videoWidth;
              flipped.height = video.videoHeight;
            }
            const fctx = flipped.getContext('2d');
            fctx.save();
            fctx.scale(-1,1); // mirror horizontally for model
            fctx.drawImage(video, -video.videoWidth, 0);
            fctx.restore();
            try{ await hands.send({image: flipped}); }
            catch(e){ log('hands.send error:', e); }
          }
          requestAnimationFrame(sendFrame);
        };
        requestAnimationFrame(sendFrame);

      }catch(err){ log('Camera failed:', err); }
    }

    startCamera();

    // cursor smoothing & state
    let prevX = window.innerWidth/2, prevY = window.innerHeight/2;
    let isPinching = false;
    let pinchStartTime = 0;
    let pinchStartY = 0;
    let startScrollY = 0;
    let isScrolling = false;
    const CLICK_MAX_DURATION = 500; // ms -> treat as click if released quickly
    const PINCH_THRESHOLD = 0.05; // normalized distance threshold for pinch
    const SCROLL_MOVE_THRESHOLD_PX = 12; // px movement before switching to scroll
    const SCROLL_FACTOR = 1.6; // adjust how finger movement maps to scroll

    function normalizedToWindow(xNorm,yNorm){
      const x = xNorm*window.innerWidth;
      const y = yNorm*window.innerHeight;
      return [x,y];
    }

    function distance(a,b){
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function elementAtCursor(x, y){
      // return topmost clickable element (ignore virtual cursor itself)
      const el = document.elementFromPoint(x, y);
      if(!el) return null;
      if(el.id === 'vcursor') {
        // temporarily hide vcursor to get underlying element
        vcursor.style.display = 'none';
        const underneath = document.elementFromPoint(x, y);
        vcursor.style.display = '';
        return underneath || null;
      }
      return el;
    }

    function performClickAt(x, y){
      const elem = elementAtCursor(x, y);
      if(elem){
        elem.dispatchEvent(new MouseEvent('mousedown', {bubbles:true, clientX:x, clientY:y}));
        elem.dispatchEvent(new MouseEvent('mouseup', {bubbles:true, clientX:x, clientY:y}));
        elem.click();
      }
    }

    function onPinchStart(x, y){
      isPinching = true;
      pinchStartTime = Date.now();
      pinchStartY = y;
      startScrollY = window.scrollY || window.pageYOffset;
      isScrolling = false;
    }

    function onPinchMove(x, y){
      // If movement exceeds threshold, enter scroll mode
      if(!isScrolling && Math.abs(y - pinchStartY) > SCROLL_MOVE_THRESHOLD_PX){
        isScrolling = true;
      }
      if(isScrolling){
        // invert movement so dragging finger up scrolls up (decrease scrollY)
        const dy = y - pinchStartY;
        const newScroll = startScrollY + dy * SCROLL_FACTOR;
        window.scrollTo({ top: newScroll, behavior: 'auto' });
      }
    }

    function onPinchEnd(x, y){
      const duration = Date.now() - pinchStartTime;
      if(isScrolling){
        // ended a scroll gesture
        // nothing additional to do for now
      } else {
        // treat as click if short press
        if(duration <= CLICK_MAX_DURATION){
          performClickAt(x, y);
        }
      }
      // reset pinch state
      isPinching = false;
      isScrolling = false;
    }

    function handlePinchState(landmarks, x, y){
      const pinchDist = distance(landmarks[8], landmarks[4]);
      const pinched = pinchDist < PINCH_THRESHOLD;

      if(pinched && !isPinching){
        onPinchStart(x, y);
      } else if(pinched && isPinching){
        // continue pinch
        onPinchMove(x, y);
      } else if(!pinched && isPinching){
        // release
        onPinchEnd(x, y);
      }
    }

    function onHands(results){
      ctx.clearRect(0,0,overlay.width,overlay.height);
      if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
        const landmarks = results.multiHandLandmarks[0];
        if(!landmarks[8] || !landmarks[4]) return;

        // Move virtual cursor to index fingertip
        const [x,y] = normalizedToWindow(landmarks[8].x, landmarks[8].y);
        const lerp = (a,b,t)=> a + (b-a)*t;
        // use smoothing factor for visual following
        prevX = lerp(prevX, x, 0.7);
        prevY = lerp(prevY, y, 0.7);
        vcursor.style.left = prevX+'px';
        vcursor.style.top = prevY+'px';

        handleHover(prevX, prevY);

        handleLetterHover(prevX, prevY);


        // Handle pinch: click vs scroll
        handlePinchState(landmarks, prevX, prevY);
      } else {
        // no hands detected: if user was pinching, consider it ended
        if(isPinching){
          onPinchEnd(prevX, prevY);
        }
      }
    }

    // ensure the cursor stays above the centered button
    vcursor.style.zIndex = 3000;

    // make sure page is scrollable so you can test scrolling
    // (if your page has no content, add tall content for testing)
  };


let lastHoverElement = null;

function handleHover(x, y){
  // get element under the hand cursor
  const elem = document.elementFromPoint(x, y);
  if(!elem) return;

  // ignore virtual cursor itself
  if(elem.id === "vcursor") {
    vcursor.style.display = "none";
    const realElem = document.elementFromPoint(x, y);
    vcursor.style.display = "";
    if(realElem) handleHoverApply(realElem);
    return;
  }

  handleHoverApply(elem);
}

function handleHoverApply(elem){
  if(elem !== lastHoverElement){
    // remove hover state from previous
    if(lastHoverElement){
      lastHoverElement.classList.remove("hand-hover");
    }
    // apply to current
    elem.classList.add("hand-hover");
    lastHoverElement = elem;
  }
}

  // button behavior
  document.getElementById('back').addEventListener('click', () => {
    window.location.href = 'hand_cursor_sync-2.html';
  });

window.addEventListener("load", () => {
  const phobia = document.getElementById("phobia");
  const text = phobia.textContent.trim();
  phobia.textContent = "";

  const words = text.split(" ");
  let wordIndex = 0;
  let letterIndex = 0;

  const speed = 35;
  let currentWordSpan = null;

  function type() {
    if (wordIndex >= words.length) return;

    if (!currentWordSpan) {
      currentWordSpan = document.createElement("span");
      currentWordSpan.className = "phobia-word";
      phobia.appendChild(currentWordSpan);
    }

    const word = words[wordIndex];

    if (letterIndex < word.length) {
      const letterSpan = document.createElement("span");
      letterSpan.className = "phobia-letter";
      letterSpan.textContent = word.charAt(letterIndex);
      currentWordSpan.appendChild(letterSpan);
      letterIndex++;
    } else {
      // finish word
      wordIndex++;
      letterIndex = 0;
      currentWordSpan = null;
    }

    setTimeout(type, speed);
  }

  type();
});

let lastLetterHover = null;

function clearRipples() {
  document.querySelectorAll(
    ".hand-letter-hover, .ripple-1, .ripple-2"
  ).forEach(el => {
    el.classList.remove("hand-letter-hover", "ripple-1", "ripple-2");
  });
}

function handleLetterHover(x, y) {
  const el = document.elementFromPoint(x, y);

  if (!el || !el.classList || !el.classList.contains("phobia-letter")) {
    clearRipples();
    lastLetterHover = null;
    return;
  }

  if (el === lastLetterHover) return;

  clearRipples();

  el.classList.add("hand-letter-hover");

  // collect all letters in order
  const letters = Array.from(
    document.querySelectorAll("#phobia .phobia-letter")
  );

  const index = letters.indexOf(el);

  if (index !== -1) {
    if (letters[index - 1]) letters[index - 1].classList.add("ripple-1");
    if (letters[index + 1]) letters[index + 1].classList.add("ripple-1");

    if (letters[index - 2]) letters[index - 2].classList.add("ripple-2");
    if (letters[index + 2]) letters[index + 2].classList.add("ripple-2");
  }

  lastLetterHover = el;
}

  </script>


  <p id="phobia">
   I am in someone’s backyard pool. There are many people attending this party, mainly adults. A man, the only one not dressed in a swimsuit but a plaid blue button down and dark pants, enters the backyard. No one seems to pay much attention to him until he walks into the pool, and we notice that he is holding a large kitchen knife. His expression never changes from a wide smile. He slashes a woman in the chest, and others try to escape from his reach. He then stabs a man in the left part of his chest. People begin running out of the water, but I am still stuck in the pool. I try desperately to swim away but the currents are too strong, and I am incredibly slow. I am eventually able to lift myself out of the pool, but the man has already set his sights on me. A boy my age is with me, in a similar situation. We run towards the fence gate, but the man catches up to us and tackles us to the ground. He orders us to stay still. At first, we do as we’re told. But both me and the boy try to run away and catch the man by surprise. We are unsuccessful, and the man stabs the boy in the lower stomach. The man then slashes multiple times at my lower stomach and then at my right knee. Both me and the boy lay paralyzed as the man gets up to flee upon hearing police sirens nearby. When I wake up, I feel a weird type of pain, almost like a burning sensation or an intense growing pain.
</p>


</body>
</html>