<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dream 13</title>
  <link rel="stylesheet" href="https://use.typekit.net/duf4kqx.css">
  <style>
    html,body{height:100%;margin:0}
    body{background:#16161d;overflow:hidden;}
    body.dream1{cursor:none}
    #container{position:relative;width:100vw;height:100vh}
    video#cam{position:fixed;left:12px;bottom:12px;width:320px;height:180px;object-fit:cover;z-index:1000;}
    canvas#overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .virtual-cursor{position:fixed;left:0;top:0;width:18px;height:18px;border-radius:50%;background:#d3cec0;transform:translate(-50%,-50%);transition:transform 0.06s linear;z-index:9999;pointer-events:none}

    /* Center dream1 button */
    #back{
      position: fixed;
      top: 64%;
      left: 2%;
      z-index: 2000; /* ensure it’s above the video */
      cursor: pointer;
      width: 7vw;
      height: 7vw;
      background-image: url('images/back.png');
      background-size: cover;
      background-color: transparent;
      border: none;
    }
    #back.hand-hover {
      background-image: url('images/backhover.png');
    }

    #phobia {
      position: absolute;
      top: 0%;
      left: 0%;
      margin: 3vw;
      color: #0022ea; 
      line-height: 1.1;
      font-size: 7vw;
      font-family: meursault-variable, serif;
      font-variation-settings: "wdth" 150, "wght" 400;
    }

#phobia .phobia-letter {
  display: inline-block;
  transition: filter 0.35s ease-out; /* smooth blur in/out */
  filter: blur(0px); /* no blur by default */
}

/* center (strongest) */
#phobia .phobia-letter.hand-letter-hover {
  filter: blur(7px); /* adjust strength to taste */
}

#phobia .phobia-letter.ripple-1 {
  filter: blur(5px);
}

#phobia .phobia-letter.ripple-2 {
  filter: blur(3px);
}

#phobia {
  max-width: 100%;
  white-space: normal;
  word-break: normal;
}

/* word container */
#phobia .phobia-word {
  display: inline-block;
  white-space: nowrap;
  margin-right: 0.25em; /* controls word spacing */
}

/* remove margin on last word */
#phobia .phobia-word:last-child {
  margin-right: 0;
}

  </style>
</head>
<body class="dream1">

  <button id="back"></button>

  <div id="container">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="virtual-cursor" id="vcursor"></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js?ver=stable"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.4/camera_utils.js?ver=stable"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.4/drawing_utils.js?ver=stable"></script>

  <script>
  window.onload = () => {
    const video = document.getElementById('cam');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    vcursor = document.getElementById('vcursor');

    function log(...args){ console.log(...args); }

    function resizeCanvas(){ overlay.width = window.innerWidth; overlay.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas); resizeCanvas();

    // Stable hands model
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`});
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.1,
      minTrackingConfidence: 0.1
    });
    hands.onResults(onHands);

    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user', width:1280, height:720}, audio:false});
        video.srcObject = stream;
        await video.play();

        // Offscreen canvas for non-mirrored input to hands
        const flipped = document.createElement('canvas');

        // Wait until video metadata is loaded to set canvas size
        video.addEventListener('loadedmetadata', () => {
          flipped.width = video.videoWidth;
          flipped.height = video.videoHeight;
        });

        const sendFrame = async () => {
          if(video.readyState >= 2){
            // ensure offscreen canvas size matches (in case loadedmetadata fired earlier)
            if (flipped.width !== video.videoWidth || flipped.height !== video.videoHeight) {
              flipped.width = video.videoWidth;
              flipped.height = video.videoHeight;
            }
            const fctx = flipped.getContext('2d');
            fctx.save();
            fctx.scale(-1,1); // mirror horizontally for model
            fctx.drawImage(video, -video.videoWidth, 0);
            fctx.restore();
            try{ await hands.send({image: flipped}); }
            catch(e){ log('hands.send error:', e); }
          }
          requestAnimationFrame(sendFrame);
        };
        requestAnimationFrame(sendFrame);

      }catch(err){ log('Camera failed:', err); }
    }

    startCamera();

    // cursor smoothing & state
    let prevX = window.innerWidth/2, prevY = window.innerHeight/2;
    let isPinching = false;
    let pinchStartTime = 0;
    let pinchStartY = 0;
    let startScrollY = 0;
    let isScrolling = false;
    const CLICK_MAX_DURATION = 500; // ms -> treat as click if released quickly
    const PINCH_THRESHOLD = 0.05; // normalized distance threshold for pinch
    const SCROLL_MOVE_THRESHOLD_PX = 12; // px movement before switching to scroll
    const SCROLL_FACTOR = 1.6; // adjust how finger movement maps to scroll

    function normalizedToWindow(xNorm,yNorm){
      const x = xNorm*window.innerWidth;
      const y = yNorm*window.innerHeight;
      return [x,y];
    }

    function distance(a,b){
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function elementAtCursor(x, y){
      // return topmost clickable element (ignore virtual cursor itself)
      const el = document.elementFromPoint(x, y);
      if(!el) return null;
      if(el.id === 'vcursor') {
        // temporarily hide vcursor to get underlying element
        vcursor.style.display = 'none';
        const underneath = document.elementFromPoint(x, y);
        vcursor.style.display = '';
        return underneath || null;
      }
      return el;
    }

    function performClickAt(x, y){
      const elem = elementAtCursor(x, y);
      if(elem){
        elem.dispatchEvent(new MouseEvent('mousedown', {bubbles:true, clientX:x, clientY:y}));
        elem.dispatchEvent(new MouseEvent('mouseup', {bubbles:true, clientX:x, clientY:y}));
        elem.click();
      }
    }

    function onPinchStart(x, y){
      isPinching = true;
      pinchStartTime = Date.now();
      pinchStartY = y;
      startScrollY = window.scrollY || window.pageYOffset;
      isScrolling = false;
    }

    function onPinchMove(x, y){
      // If movement exceeds threshold, enter scroll mode
      if(!isScrolling && Math.abs(y - pinchStartY) > SCROLL_MOVE_THRESHOLD_PX){
        isScrolling = true;
      }
      if(isScrolling){
        // invert movement so dragging finger up scrolls up (decrease scrollY)
        const dy = y - pinchStartY;
        const newScroll = startScrollY + dy * SCROLL_FACTOR;
        window.scrollTo({ top: newScroll, behavior: 'auto' });
      }
    }

    function onPinchEnd(x, y){
      const duration = Date.now() - pinchStartTime;
      if(isScrolling){
        // ended a scroll gesture
        // nothing additional to do for now
      } else {
        // treat as click if short press
        if(duration <= CLICK_MAX_DURATION){
          performClickAt(x, y);
        }
      }
      // reset pinch state
      isPinching = false;
      isScrolling = false;
    }

    function handlePinchState(landmarks, x, y){
      const pinchDist = distance(landmarks[8], landmarks[4]);
      const pinched = pinchDist < PINCH_THRESHOLD;

      if(pinched && !isPinching){
        onPinchStart(x, y);
      } else if(pinched && isPinching){
        // continue pinch
        onPinchMove(x, y);
      } else if(!pinched && isPinching){
        // release
        onPinchEnd(x, y);
      }
    }

    function onHands(results){
      ctx.clearRect(0,0,overlay.width,overlay.height);
      if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
        const landmarks = results.multiHandLandmarks[0];
        if(!landmarks[8] || !landmarks[4]) return;

        // Move virtual cursor to index fingertip
        const [x,y] = normalizedToWindow(landmarks[8].x, landmarks[8].y);
        const lerp = (a,b,t)=> a + (b-a)*t;
        // use smoothing factor for visual following
        prevX = lerp(prevX, x, 0.7);
        prevY = lerp(prevY, y, 0.7);
        vcursor.style.left = prevX+'px';
        vcursor.style.top = prevY+'px';

        handleHover(prevX, prevY);

        handleLetterHover(prevX, prevY);


        // Handle pinch: click vs scroll
        handlePinchState(landmarks, prevX, prevY);
      } else {
        // no hands detected: if user was pinching, consider it ended
        if(isPinching){
          onPinchEnd(prevX, prevY);
        }
      }
    }

    // ensure the cursor stays above the centered button
    vcursor.style.zIndex = 3000;

    // make sure page is scrollable so you can test scrolling
    // (if your page has no content, add tall content for testing)
  };


let lastHoverElement = null;

function handleHover(x, y){
  // get element under the hand cursor
  const elem = document.elementFromPoint(x, y);
  if(!elem) return;

  // ignore virtual cursor itself
  if(elem.id === "vcursor") {
    vcursor.style.display = "none";
    const realElem = document.elementFromPoint(x, y);
    vcursor.style.display = "";
    if(realElem) handleHoverApply(realElem);
    return;
  }

  handleHoverApply(elem);
}

function handleHoverApply(elem){
  if(elem !== lastHoverElement){
    // remove hover state from previous
    if(lastHoverElement){
      lastHoverElement.classList.remove("hand-hover");
    }
    // apply to current
    elem.classList.add("hand-hover");
    lastHoverElement = elem;
  }
}

  // button behavior
  document.getElementById('back').addEventListener('click', () => {
    window.location.href = 'hand_cursor_sync-2.html';
  });

window.addEventListener("load", () => {
  const phobia = document.getElementById("phobia");
  const text = phobia.textContent.trim();
  phobia.textContent = "";

  const words = text.split(" ");
  let wordIndex = 0;
  let letterIndex = 0;

  const speed = 35;
  let currentWordSpan = null;

  function type() {
    if (wordIndex >= words.length) return;

    if (!currentWordSpan) {
      currentWordSpan = document.createElement("span");
      currentWordSpan.className = "phobia-word";
      phobia.appendChild(currentWordSpan);
    }

    const word = words[wordIndex];

    if (letterIndex < word.length) {
      const letterSpan = document.createElement("span");
      letterSpan.className = "phobia-letter";
      letterSpan.textContent = word.charAt(letterIndex);
      currentWordSpan.appendChild(letterSpan);
      letterIndex++;
    } else {
      // finish word
      wordIndex++;
      letterIndex = 0;
      currentWordSpan = null;
    }

    setTimeout(type, speed);
  }

  type();
});

let lastLetterHover = null;

function clearRipples() {
  document.querySelectorAll(
    ".hand-letter-hover, .ripple-1, .ripple-2"
  ).forEach(el => {
    el.classList.remove("hand-letter-hover", "ripple-1", "ripple-2");
  });
}

function handleLetterHover(x, y) {
  const el = document.elementFromPoint(x, y);

  if (!el || !el.classList || !el.classList.contains("phobia-letter")) {
    clearRipples();
    lastLetterHover = null;
    return;
  }

  if (el === lastLetterHover) return;

  clearRipples();

  el.classList.add("hand-letter-hover");

  // collect all letters in order
  const letters = Array.from(
    document.querySelectorAll("#phobia .phobia-letter")
  );

  const index = letters.indexOf(el);

  if (index !== -1) {
    if (letters[index - 1]) letters[index - 1].classList.add("ripple-1");
    if (letters[index + 1]) letters[index + 1].classList.add("ripple-1");

    if (letters[index - 2]) letters[index - 2].classList.add("ripple-2");
    if (letters[index + 2]) letters[index + 2].classList.add("ripple-2");
  }

  lastLetterHover = el;
}

  </script>


  <p id="phobia">
   I am at home from college for a break. I slept in late. Once I come out of my room, mom says she has something to tell me. She has a serious look on her face but still manages a small smile. I’m brought to the front door when mom opens the door to a group of policemen. An officer tells me that early this morning while I was asleep, they found the body of a man killed several years ago, and mom is under investigation as the lead suspect. Mom is allowed to travel freely until they have concrete proof that she is the killer and a court case is started. She has to drive me back to college that same day. Throughout the car ride, we talk about many things, and I ask her many questions. I never felt scared of her. At one point in the car ride, a group of girls on the side of the road walk out in front of our car and start laughing and sneering at us, mostly ridiculing me for crying. Both mom and I exit the car to try and convince them to move out the way. I am emotional, and I eventually resort to physical violence. I punch one of the girls in the stomach, then I start pulling her hair. Mom pulls her out and away from in front of the car. We get back in the car, but the girl hurries back to block the car again. Fed up, mom pushes the gas and runs her over. I start crying harder. Mom tries to calm me down. We arrive in midtown and mom asks if there’s any place with birds nearby. I mention a conservatory inside a high rise building that has both birds and a nice view of Manhattan. We never end up going to see the view. Once we arrive, we both step out of the car. We hug for the last time. I'm choking up and struggling to breathe. I make mom pinky promise that if she ends up in prison, she’ll send someone to tell me so I can visit her. She tries to avoid the pinky promise, but I take her hand and force her pinky to link with mine. Only then does she start crying. I wake up with tears in my eyes.
</p>


</body>
</html>