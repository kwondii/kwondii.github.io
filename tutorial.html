<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tutorial</title>
  <link href="styles.css" rel="stylesheet">
  <style>
    html,body{height:100%;margin:0}
    body{background:#16161d;overflow:hidden;}
    body.tutorial{cursor:none}
    #container{position:relative;width:100vw;height:100vh}
    video#cam{position:fixed;left:12px;bottom:12px;width:320px;height:180px;object-fit:cover;z-index:1000;}
    canvas#overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .virtual-cursor{position:fixed;left:0;top:0;width:18px;height:18px;border-radius:50%;background:#d3cec0;transform:translate(-50%,-50%);transition:transform 0.06s linear;z-index:9999;pointer-events:none}

body.tutorial {
        background-image: url(images/tut.jpg);
        background-color: #16161d;
        background-repeat: no-repeat; /* Prevents the image from repeating */
        background-size: cover; /* Scales the image to cover the entire element */
        background-position: center; /* Centers the image */
    }

    /* Center dream1 button */
    #tutorial{
      position: absolute;
      top: 27%;
      left: 43%;
      z-index: 2000; /* ensure itâ€™s above the video */
      cursor: pointer;
      width: 30vw;
      height: 30vw;
      background-image: url('images/tree.png');
      background-size: cover;
      background-position: center;
      background-color: transparent;
      border: none;
    }
    #tutorial.hand-hover {
          transform: scale(1.05); 
        }
  </style>
</head>
<body class="tutorial">

  <button id="tutorial"></button>

  <div id="container">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="virtual-cursor" id="vcursor"></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js?ver=stable"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.4/camera_utils.js?ver=stable"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.4/drawing_utils.js?ver=stable"></script>

  <script>
  window.onload = () => {
    const video = document.getElementById('cam');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const vcursor = document.getElementById('vcursor');

    function log(...args){ console.log(...args); }

    function resizeCanvas(){ overlay.width = window.innerWidth; overlay.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas); resizeCanvas();

    // Stable hands model
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`});
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.1,
      minTrackingConfidence: 0.1
    });
    hands.onResults(onHands);

    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user', width:1280, height:720}, audio:false});
        video.srcObject = stream;
        await video.play();

        // Offscreen canvas for non-mirrored input to hands
        const flipped = document.createElement('canvas');

        // Wait until video metadata is loaded to set canvas size
        video.addEventListener('loadedmetadata', () => {
          flipped.width = video.videoWidth;
          flipped.height = video.videoHeight;
        });

        const sendFrame = async () => {
          if(video.readyState >= 2){
            // ensure offscreen canvas size matches (in case loadedmetadata fired earlier)
            if (flipped.width !== video.videoWidth || flipped.height !== video.videoHeight) {
              flipped.width = video.videoWidth;
              flipped.height = video.videoHeight;
            }
            const fctx = flipped.getContext('2d');
            fctx.save();
            fctx.scale(-1,1); // mirror horizontally for model
            fctx.drawImage(video, -video.videoWidth, 0);
            fctx.restore();
            try{ await hands.send({image: flipped}); }
            catch(e){ log('hands.send error:', e); }
          }
          requestAnimationFrame(sendFrame);
        };
        requestAnimationFrame(sendFrame);

      }catch(err){ log('Camera failed:', err); }
    }

    startCamera();

    // cursor smoothing & state
    let prevX = window.innerWidth/2, prevY = window.innerHeight/2;
    let isPinching = false;
    let pinchStartTime = 0;
    let pinchStartY = 0;
    let startScrollY = 0;
    let isScrolling = false;
    const CLICK_MAX_DURATION = 500; // ms -> treat as click if released quickly
    const PINCH_THRESHOLD = 0.05; // normalized distance threshold for pinch
    const SCROLL_MOVE_THRESHOLD_PX = 12; // px movement before switching to scroll
    const SCROLL_FACTOR = 1.6; // adjust how finger movement maps to scroll

    function normalizedToWindow(xNorm,yNorm){
      const x = xNorm*window.innerWidth;
      const y = yNorm*window.innerHeight;
      return [x,y];
    }

    function distance(a,b){
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function elementAtCursor(x, y){
      // return topmost clickable element (ignore virtual cursor itself)
      const el = document.elementFromPoint(x, y);
      if(!el) return null;
      if(el.id === 'vcursor') {
        // temporarily hide vcursor to get underlying element
        vcursor.style.display = 'none';
        const underneath = document.elementFromPoint(x, y);
        vcursor.style.display = '';
        return underneath || null;
      }
      return el;
    }

    function performClickAt(x, y){
      const elem = elementAtCursor(x, y);
      if(elem){
        elem.dispatchEvent(new MouseEvent('mousedown', {bubbles:true, clientX:x, clientY:y}));
        elem.dispatchEvent(new MouseEvent('mouseup', {bubbles:true, clientX:x, clientY:y}));
        elem.click();
      }
    }

    function onPinchStart(x, y){
      isPinching = true;
      pinchStartTime = Date.now();
      pinchStartY = y;
      startScrollY = window.scrollY || window.pageYOffset;
      isScrolling = false;
    }

    function onPinchMove(x, y){
      // If movement exceeds threshold, enter scroll mode
      if(!isScrolling && Math.abs(y - pinchStartY) > SCROLL_MOVE_THRESHOLD_PX){
        isScrolling = true;
      }
      if(isScrolling){
        // invert movement so dragging finger up scrolls up (decrease scrollY)
        const dy = y - pinchStartY;
        const newScroll = startScrollY + dy * SCROLL_FACTOR;
        window.scrollTo({ top: newScroll, behavior: 'auto' });
      }
    }

    function onPinchEnd(x, y){
      const duration = Date.now() - pinchStartTime;
      if(isScrolling){
        // ended a scroll gesture
        // nothing additional to do for now
      } else {
        // treat as click if short press
        if(duration <= CLICK_MAX_DURATION){
          performClickAt(x, y);
        }
      }
      // reset pinch state
      isPinching = false;
      isScrolling = false;
    }

    function handlePinchState(landmarks, x, y){
      const pinchDist = distance(landmarks[8], landmarks[4]);
      const pinched = pinchDist < PINCH_THRESHOLD;

      if(pinched && !isPinching){
        onPinchStart(x, y);
      } else if(pinched && isPinching){
        // continue pinch
        onPinchMove(x, y);
      } else if(!pinched && isPinching){
        // release
        onPinchEnd(x, y);
      }
    }

    function onHands(results){
      ctx.clearRect(0,0,overlay.width,overlay.height);
      if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
        const landmarks = results.multiHandLandmarks[0];
        if(!landmarks[8] || !landmarks[4]) return;

        // Move virtual cursor to index fingertip
        const [x,y] = normalizedToWindow(landmarks[8].x, landmarks[8].y);
        const lerp = (a,b,t)=> a + (b-a)*t;
        // use smoothing factor for visual following
        prevX = lerp(prevX, x, 0.7);
        prevY = lerp(prevY, y, 0.7);
        vcursor.style.left = prevX+'px';
        vcursor.style.top = prevY+'px';

        handleHover(prevX, prevY);

        // Handle pinch: click vs scroll
        handlePinchState(landmarks, prevX, prevY);
      } else {
        // no hands detected: if user was pinching, consider it ended
        if(isPinching){
          onPinchEnd(prevX, prevY);
        }
      }
    }

    // ensure the cursor stays above the centered button
    vcursor.style.zIndex = 3000;

    // make sure page is scrollable so you can test scrolling
    // (if your page has no content, add tall content for testing)
  };

let lastHoverElement = null;

function handleHover(x, y){
  // get element under the hand cursor
  const elem = document.elementFromPoint(x, y);
  if(!elem) return;

  // ignore virtual cursor itself
  if(elem.id === "vcursor") {
    vcursor.style.display = "none";
    const realElem = document.elementFromPoint(x, y);
    vcursor.style.display = "";
    if(realElem) handleHoverApply(realElem);
    return;
  }

  handleHoverApply(elem);
}

function handleHoverApply(elem){
  if(elem !== lastHoverElement){
    // remove hover state from previous
    if(lastHoverElement){
      lastHoverElement.classList.remove("hand-hover");
    }
    // apply to current
    elem.classList.add("hand-hover");
    lastHoverElement = elem;
  }
}

  // center button behavior
  document.getElementById('tutorial').addEventListener('click', () => {
      window.location.href = 'hand_cursor_sync-2.html';
    });
  </script>
</body>
</html>